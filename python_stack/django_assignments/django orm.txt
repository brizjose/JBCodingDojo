Django ORM

Objects are created in models.py then imported to views.py

  # Inside models.py
  from __future__ import unicode_literals
  from django.db import models
  # Create your models here.

  class User(models.Model):
      username = models.CharField(max_length=255)
      password = models.CharField(max_length=255)
      created_at = models.DateTimeField(auto_now_add = True)
      updated_at = models.DateTimeField(auto_now = True)
      def__repr__(self):
	return "<User object: {}>".format(self.username)

  class Blog(models.Model):
      name = models.CharField(max_length=255)
      desc = models.TextField()
      user = models.ForeignKey(User)
      created_at = models.DateTimeField(auto_now_add = True)
      updated_at = models.DateTimeField(auto_now = True)
      def__repr__(self):
	return "<Blog object: {} {}>".format(self.name, self.desc)

  class Comment(models.Model):
      comment = models.CharField(max_length=255)
      created_at = models.DateTimeField(auto_now_add = True)
      updated_at = models.DateTimeField(auto_now = True)
      blog = models.ForeignKey(Blog, related_name = "comments")		---one to many relationship
      
  class Admin(models.Model):
      first_name = models.CharField(max_length=255)
      last_name = models.CharField(max_length=255)
      email = models.CharField(max_length=255)
      blogs = models.ManyToManyField(Blog, related_name = "admins")	---many to many relationship
      created_at = models.DateTimeField(auto_now_add = True)
      updated_at = models.DateTimeField(auto_now = True)
      def__repr__(self):
	return "<Admin: {} {}>".format(self.first_name, self.last_name)

  class AdminInBlog(models.Model)					---many to many relationship table
      user = models.ForeignKey(User)
      blog = models.ForeignKey(Blog)

Note:  the def__repr__(self):  method is helpful as this is the info about the object that will get printed on queries, instead of the <objea;sldkj>. 

Related_name:

	used to do reverse queries

Column Types:

	models.CharField -- has a required parameter max_length
	models.TextField -- has no maximum length, can be set as blank=True
	models.IntegerField
	models.BooleanField
	models.DateTimeField -- can take parameter to auto populate it upon creation of record:  auto_now_add=True which is useful for created_at
				-- can take one that auto updates any time the object is modified:  auto_now=True which is useful for updated_at
	models.ForeignKey  -- these go in the "many" side, just like in SQL -- models.ForeignKey(Blog, related_name="comments")
	models.ManyToManyField -- use in the many side that makes more sense -- models.ManyToManyField(Blog, related_name="admins")
	models.OneToOneField

Migrations

Necessary when database are set up and every time they are updated:

	>python manage.py makemigrations  	--- stages the changes
	>python manage.py migrate		--- applies the changes

Database

during production, Django uses SQLite
for deployment, better switch to MySQL

The Django ORM queries will be the same no matter which database is used

Python Shell

-python shell helps navigate objects

	>python manage.py shell

-import one or many models

	>from apps.{{app_name}}.models import *   ---- or replace * with specific models you want to work with, example Author, Book, Publisher

Methods

Some methods will run through the manager, some methods will run from the object model itself.  
For example:
	
	Blog.objects.create() 	runs through the manager
	
	Blog.name = "Bob"
	Blog.save()		runs through the object model	


ORM Commands

1. Creating a new record:
	
	Blog.objects.create(name="Coding Dojo", desc="cool lectures", user=...)    note that user requires a user instance because it's a foreignkey

	Blog.objects.create(name="Coding Dojo", desc="cool lectures", user=User.objects.get(id=#))

2. Alternative way of creating a new record

	b = Blog(name="Coding Dojo", desc="cool lectures")
	b.name = "Coding Dojo"
	b.desc = "cool lectures"
	b.save()

3. Retrieve
	Blog.objects.all()		---retrieves all objects as a list	
	Blog.objects.all()[0]   	---retrieves the first object 
	Blog.objects.get(id=#)		---retrives an object, example, if id=4 does not exist, returns an error DoesNotExist
	Blog.objects.filter(id=#)  	---retrieves a list, example, if id=4 does not exist, returns an empty list []
	Blog.objects.first()
	Blog.objects.last()
	Blog.objects.count()
	Blog.objects.exclude(name="Bambi")
	Blog.objects.order_by("created_at")
	Blog.objects.order_by("-created_at")  -- revereses the order
	Blog.objects.raw(SELECT * FROM {{ app name }}_{{ class or table name }})  -- use raw SQL queries
	Blog.objects.first().comments.all()    ---get all comments from first blog
	Blog.objects.get(id=14).comments.first()   ---get the first comment of blog # 14
	Comment.objects.get(id=15).blog.name   ---get blog name where comment id#15 was posted
	Admin.objects.filter(first_name__startswith="S")   ---filters objects with first_name that starts with "S"
	Admin.objects.exclude(first_name__contains="E")   ---excludes objects where first_name contains "E"
	Admin.objects.filter(age__gt=80)    ---filters objects with age greater than 80
	Author.objects.filter(email__contains="ruby")    ---gets all authors with an email containing word "ruby"

4.  Combining and assigning:   it can get complicated.   if too complicated, best to use raw queries
	
	admin = Admin.objects.filter(last_name__contains="o").exclude(first_name__contains="o")
	admin = Admin.objects.filter(age__lt=70)|Admin.objects.filter(first_name__startswith="S")

	
5. Update
	
	b = Blog.objects.first()
	b.name = "JinjaExpert"
	b.save()

6. Delete record

	b = Blog.objects.get(id=3)
	b.delete()

7. Set a relationship

	One to one:	
	
	Blog.objects.create(title="my first blog", desc="pour my ideas here", user=User.objects.get(id="3"))   ---creates one to one
	
	Retrieving with one to one:
		
	Blog.objects.get(id=1).title		---gets the blog title
	Blog.objects.get(id=1).user_id		---gets the user id
	Blog.objects.get(id=1).user		---gets the user object itself

	One to many:

	Comment.objects.create(comment = "test", blog = Blog.objects.get(id=15))   ---creates new comment pointing to Blog id # 15	

	query to find the blog's name:
	
	Comment.objects.get(id=1).blog.name	---query returns comment ID one, then we can find the name of the blog it is in
	Comment.objects.all()[0].blog.name     ---query returns all comments, then we can get the name of the blog where the 1st comment is

	query with the related name:

	Blog.objects.get(id=1).comments.all()	---returns a list of all comments in blog id one 

	Many to many:

		If on a table:

	AdminInBlog.objects.create(user=User.objects.get(id=2), blog=Blog.objects.get(id=3))  ---creates admin in blog relationship

		If relationship has been defined on one line within the object:
	
	s1 = Student.objects.get(id=3)
	c1 = Course.objects.get(id=6)
	s1.students.add(c1)		---to create the relationship
	s1.students.remove(c1)   	---to remove relationship

	what user is admin of a blog?
	
	AdminInBlog.objects.filter(blog=Blog.objects.get(id=3))		---gets the list of users that are admins of blog id 3
	AdminInBlog.objects.filter(blog=Blog.objects.get(id=3))[0].user.username    ---gets the username of the first admin
	AdminInBlog.objects.filter(blog=Blog.objects.get(id=3))[1].user.username    ---gets the username of the first admin
	

